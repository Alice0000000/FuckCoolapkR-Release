// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENCODEVALUE_DEXKIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_ENCODEVALUE_DEXKIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace dexkit {
namespace schema {

struct EncodeValueByte;
struct EncodeValueByteBuilder;

struct EncodeValueShort;
struct EncodeValueShortBuilder;

struct EncodeValueChar;
struct EncodeValueCharBuilder;

struct EncodeValueInt;
struct EncodeValueIntBuilder;

struct EncodeValueLong;
struct EncodeValueLongBuilder;

struct EncodeValueFloat;
struct EncodeValueFloatBuilder;

struct EncodeValueDouble;
struct EncodeValueDoubleBuilder;

struct EncodeValueString;
struct EncodeValueStringBuilder;

struct EncodeValueNull;
struct EncodeValueNullBuilder;

struct EncodeValueBoolean;
struct EncodeValueBooleanBuilder;

struct EncodeValueByte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueByteBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct EncodeValueByteBuilder {
  typedef EncodeValueByte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(EncodeValueByte::VT_VALUE, value, 0);
  }
  explicit EncodeValueByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueByte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueByte> CreateEncodeValueByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  EncodeValueByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueByte::Traits {
  using type = EncodeValueByte;
  static auto constexpr Create = CreateEncodeValueByte;
};

struct EncodeValueShort FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueShortBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct EncodeValueShortBuilder {
  typedef EncodeValueShort Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(EncodeValueShort::VT_VALUE, value, 0);
  }
  explicit EncodeValueShortBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueShort>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueShort> CreateEncodeValueShort(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  EncodeValueShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueShort::Traits {
  using type = EncodeValueShort;
  static auto constexpr Create = CreateEncodeValueShort;
};

struct EncodeValueChar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueCharBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct EncodeValueCharBuilder {
  typedef EncodeValueChar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(EncodeValueChar::VT_VALUE, value, 0);
  }
  explicit EncodeValueCharBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueChar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueChar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueChar> CreateEncodeValueChar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  EncodeValueCharBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueChar::Traits {
  using type = EncodeValueChar;
  static auto constexpr Create = CreateEncodeValueChar;
};

struct EncodeValueInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueIntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct EncodeValueIntBuilder {
  typedef EncodeValueInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(EncodeValueInt::VT_VALUE, value, 0);
  }
  explicit EncodeValueIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueInt> CreateEncodeValueInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  EncodeValueIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueInt::Traits {
  using type = EncodeValueInt;
  static auto constexpr Create = CreateEncodeValueInt;
};

struct EncodeValueLong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueLongBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct EncodeValueLongBuilder {
  typedef EncodeValueLong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(EncodeValueLong::VT_VALUE, value, 0);
  }
  explicit EncodeValueLongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueLong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueLong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueLong> CreateEncodeValueLong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  EncodeValueLongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueLong::Traits {
  using type = EncodeValueLong;
  static auto constexpr Create = CreateEncodeValueLong;
};

struct EncodeValueFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueFloatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct EncodeValueFloatBuilder {
  typedef EncodeValueFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(EncodeValueFloat::VT_VALUE, value, 0.0f);
  }
  explicit EncodeValueFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueFloat> CreateEncodeValueFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  EncodeValueFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueFloat::Traits {
  using type = EncodeValueFloat;
  static auto constexpr Create = CreateEncodeValueFloat;
};

struct EncodeValueDouble FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueDoubleBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct EncodeValueDoubleBuilder {
  typedef EncodeValueDouble Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(EncodeValueDouble::VT_VALUE, value, 0.0);
  }
  explicit EncodeValueDoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueDouble>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueDouble> CreateEncodeValueDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  EncodeValueDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueDouble::Traits {
  using type = EncodeValueDouble;
  static auto constexpr Create = CreateEncodeValueDouble;
};

struct EncodeValueString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct EncodeValueStringBuilder {
  typedef EncodeValueString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(EncodeValueString::VT_VALUE, value);
  }
  explicit EncodeValueStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueString> CreateEncodeValueString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  EncodeValueStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueString::Traits {
  using type = EncodeValueString;
  static auto constexpr Create = CreateEncodeValueString;
};

inline ::flatbuffers::Offset<EncodeValueString> CreateEncodeValueStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return dexkit::schema::CreateEncodeValueString(
      _fbb,
      value__);
}

struct EncodeValueNull FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueNullBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct EncodeValueNullBuilder {
  typedef EncodeValueNull Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(EncodeValueNull::VT_VALUE, value, 0);
  }
  explicit EncodeValueNullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueNull> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueNull>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueNull> CreateEncodeValueNull(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  EncodeValueNullBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueNull::Traits {
  using type = EncodeValueNull;
  static auto constexpr Create = CreateEncodeValueNull;
};

struct EncodeValueBoolean FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodeValueBooleanBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct EncodeValueBooleanBuilder {
  typedef EncodeValueBoolean Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(EncodeValueBoolean::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit EncodeValueBooleanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodeValueBoolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodeValueBoolean>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodeValueBoolean> CreateEncodeValueBoolean(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  EncodeValueBooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EncodeValueBoolean::Traits {
  using type = EncodeValueBoolean;
  static auto constexpr Create = CreateEncodeValueBoolean;
};

}  // namespace schema
}  // namespace dexkit

#endif  // FLATBUFFERS_GENERATED_ENCODEVALUE_DEXKIT_SCHEMA_H_
